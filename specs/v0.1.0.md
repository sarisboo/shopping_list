# Shopping List Tech Specs v0.1.0

## Overview
This project is aimed at optimising the grocery shopping process by generating a list of favourite recipes and from that, extracting another list of necessary ingredients and their amounts.

Our approach will be to create a relational database of our favourite recipes and extract all the information we need using a REST API. The overall time estimate for this project is one week.

## Goals and Product Requirement
We spend a lot of time picking a recipe, testing it  or trying to remember on which website/cookbook it was  and when we are finally done collecting a list of recipes. We still have to list all the ingredients necessary to go grocery shopping in the night amounts. 

In order to stop wasting time on these monotonous tasks, we propose a way to automate the process by selecting a number of recipes for the week (taking into account the rating criteria, ingredient similarity etc…) to generate an optimised grocery shopping list. 

## Approach 

### SQLite DB Browser

We will use Sqlite DB Browser to store the database with a table listing all our favourite recipes. Each recipe will have a characteristic ID. Another table will be containing all the ingredients necessary for the listed recipes . 

Ingredients can be linked to one or more recipe so  the final grocery list will have the total number of each ingredient necessary to the realisation of all selected recipes.

#### Creating Relational Database

1. First table: Recipes

	Each column in the table will have a field name as follows:
		- recipe_id: primary key field for each recipe
		- recipe_name: name of the recipe
		- rating: grade of the recipe (max value is 5)
		- total_time: prep time + cooking time
		
2. Joining table:  
		- recipe_id
		- ingredient_id
		
3. Second Table : Ingredients
		- Ingredient_id:  unique id for each ingredient
		- ingredients_name:  name of the ingredient

### Python 3.6.5

This project will be written in Python 3.6.5 and we will use SQLite to create a database. We chose SQLite because it comes with python and doesn’t have to be installed as a separate module.

We are going to create a new utility program called `build_database.py` to create a initialise the database. 
We will also create two python modules `config.py` and `models.py` which will be used by   `build_database.py` 

#### The Config Module

We’re going to configure Flask, Connexion, SQLAlchemy, and Marshmallow here.
	- `config.py`:gets the necessary modules imported into the program and configured. This includes Flask, Connexion, SQLAlchemy, and Marshmallow. Because it will be used by both `build_database.py`
	Here is an example of a  `config.py` file:

#### Models Module

The `models.py` module is created to provide the Person and PersonSchema classes .
	- `models.py`is the module where you’ll create the Recipe SQLAlchemy and RecipeSchema Marshmallow class definitions described above. This module is dependent on `config.py` for some of the objects created and configured there.
	
### Flask- SQLAlchemy

We will interact with the data using SQLAlchemy, creating SQLAlchemy classes to connect the fields from the database table rows to behaviour.

SQLAlchemy will allow us to generate SQL queries by running python code and will return a python object, where each of the fields is an attribute of the object.  It will also avoid Little Bobby Tables since it will sanitise user data before creating SQL statements.

By creating SQLAlchemy classes, We’ll be able to connect the fields from the database table rows to behaviour, allowing us  to interact with the data.
For example:

```
class Recipe(db.Model):
    __tablename__ = 'recipes'
    recipe_id = db.Column(db.Integer, 
                          primary_key=True)
    recipe_name = db.Column(db.Integer)
    rating = db.Column(db.String)
    total_time = db.Column(db.Integer)
```

#### Creating the Database 

To create the database and populate it with data. We’re going to build a small utility program to create and build the database with the data. Here’s the `build_database.py` program:

```
import os
from config import db
from models import Recipe

# Data to initialize database with
RECIPES = [
    {'recipe_name': 'Poulet au gingembre', 'rating': 4/5, total_time = 25},
    {'recipe_name': 'Tajine aux Pruneaux', 'rating': 5/5 total_time = 120},
]

# Delete database file if it exists currently
if os.path.exists('recipes.db'):
    os.remove('recipes.db')

# Create the database
db.create_all()

# Iterate over the RECIPE structure and populate the database
for recipe in RECIPES:
    r = Recipe(recipe_name = recipe['recipe_name'], rating =recipe['rating'])
    db.session.add(r)

db.session.commit()
```

#### Connection to the Database

We need to create a engine so we import:

		`from sqlalchemy import create_engine`

We then create  an engine and supply the connection string to provide the details  to find and connect to the database.

Connection Strings example: (in the working directory)

	`'sqlite:///recipes.sqlite'`
	Driver       +      Dialect     + Filename

In order to know what is in the database before querying it, we’ll use:

```
In [1]: from sqlalchemy import create_engine
In [2]: engine = create_engine('sqlite:///recipes.sqlite')
In [3]: print(engine.table_names())
Out[3]: ['recipe_list', 'ingredient_list', 'ids']
```

Note: You don’t need to connect to the database to print the tables or metadata.

#### Reflection

Reads the database and builds SQLAlchemy table objects. The metadata object is  a catalog that stores db info such as tables so we don’t have to keep looking them up.

```
In [1]: from sqlalchemy import Metadata, Table
In [2]: metadata = Metadata()
In [3]: recipe = Table('recipe_list', metadata, autoload = True, autoload_with = engine)
# To view the details of the stored table 
In [4]: print(repr(recipe_list))
```

To learn more about the columns and the structure of the table We can use:

`recipe_list.columns.keys()`

This would return a list of column names of the recipe_list table.
We can use the metadata container to find out more details about the reflected table such as the columns and their types.

Table objects are stored in the metadata.tables dictionary.
```
# Print full table metadata
print(repr(metadata.tables['recipe_list']))
```

#### Basic SQL Querying 

```
from sqlachemy import create_engine
engine = create_engine('sqlite:///recipe_list.sqlite')
connection = engine.connect()
stmt = 'SELECT * FROM recipes'
result_proxy = connection.execute(stmt)
results = result_proxy.fetchall()
```

`stmt = 'SELECT * FROM recipes'`  can be passed  to the execute method of the connection gives an object that we can use to fetch results .

When fetch methods is used on ResultProxy we get a ResultSet, that contains the actual data we asked for in the query. 

- Handling ResultSets
```
first_row = results[0]
print(first_row) # to see data it contains

# To see the columns
print(first_row.keys())

# printing the result of the first row column

print(first_row.state) #col name as attribute in the row object
```

#### SQLAlchemy to Build Queries

- More ‘Pythonic”
- Hides the differences between backend databases types

Rebuilding the same queries using SQLAlchemy:

```
from sqlalchemy import Table, Metatdata
from sqlachemy import create_engine, select

#Create engine and establishing connection
engine = create_engine('sqlite:///recipes.sqlite')
connection = engine.connect()

# Initializing metadata
metadata = Metadata() 

# Reflecting a table
census = Table('recipe_list', metadata, autoload= True, autoload_with = engine)

stmt = select([census])# Converts into SQL statement
results = connection.execute(stmt).fetchall()
```


### Marshmallow

It is a module that helps us create a `RecipeSchema` class for instance  but instead of mapping database tables and field names to the class and its attributes, the `RecipeSchema` class defines how the attributes of a class will be converted into JSON-friendly formats.

```
class RecipeSchema(ma.ModelSchema):
    class Meta:
        model = Recipe
        sqla_session = db.session
```

With this class definition, want to be able to serialise an instance of a `Recipe`class into JSON data, and to deserialise JSON data and create a `Recipe` class instances from it.

- **class Meta** defines a class named Meta within your class. The ModelSchema class that the RecipeSchema class inherits from looks for this internal Meta class and uses it to find the SQLAlchemy model Recipe and the db.session. This is how Marshmallow finds attributes in the Recipe class and the type of those attributes so it knows how to serialise/deserialise them.

- **model** tells the class what SQLAlchemy model to use to serialise/deserialise data to and from.

- **db.session** tells the class what database session to use to introspect and determine attribute data types.


### Flask
The API will be built using the Flask-RESTful  extension of Flask .  A model should be able to Create, Read, Update and delete resources . 
 We will add an endpoint that suggests recipes for the week (first randomly and later based on various criteria) and and another one that will generate the grocery list.
The following is an example of ReST actions for a collection called people:
```
# System modules
from datetime import datetime

# 3rd party modules
from flask import make_response, abort


def get_timestamp():
    return datetime.now().strftime(("%Y-%m-%d %H:%M:%S"))


# Data to serve with our API
PEOPLE = {
    "Farrell": {
        "fname": "Doug",
        "lname": "Farrell",
        "timestamp": get_timestamp(),
    },
    "Brockman": {
        "fname": "Kent",
        "lname": "Brockman",
        "timestamp": get_timestamp(),
    },
    "Easter": {
        "fname": "Bunny",
        "lname": "Easter",
        "timestamp": get_timestamp(),
    },
}


def read_all():
    """
    This function responds to a request for /api/people
    with the complete lists of people
    :return:        json string of list of people
    """
    # Create the list of people from our data
    return [PEOPLE[key] for key in sorted(PEOPLE.keys())]


def read_one(lname):
    """
    This function responds to a request for /api/people/{lname}
    with one matching person from people
    :param lname:   last name of person to find
    :return:        person matching last name
    """
    # Does the person exist in people?
    if lname in PEOPLE:
        person = PEOPLE.get(lname)

    # otherwise, nope, not found
    else:
        abort(
            404, "Person with last name {lname} not found".format(lname=lname)
        )

    return person


def create(person):
    """
    This function creates a new person in the people structure
    based on the passed in person data
    :param person:  person to create in people structure
    :return:        201 on success, 406 on person exists
    """
    lname = person.get("lname", None)
    fname = person.get("fname", None)

    # Does the person exist already?
    if lname not in PEOPLE and lname is not None:
        PEOPLE[lname] = {
            "lname": lname,
            "fname": fname,
            "timestamp": get_timestamp(),
        }
        return make_response(
            "{lname} successfully created".format(lname=lname), 201
        )

    # Otherwise, they exist, that's an error
    else:
        abort(
            406,
            "Peron with last name {lname} already exists".format(lname=lname),
        )


def update(lname, person):
    """
    This function updates an existing person in the people structure
    :param lname:   last name of person to update in the people structure
    :param person:  person to update
    :return:        updated person structure
    """
    # Does the person exist in people?
    if lname in PEOPLE:
        PEOPLE[lname]["fname"] = person.get("fname")
        PEOPLE[lname]["timestamp"] = get_timestamp()

        return PEOPLE[lname]

    # otherwise, nope, that's an error
    else:
        abort(
            404, "Person with last name {lname} not found".format(lname=lname)
        )


def delete(lname):
    """
    This function deletes a person from the people structure
    :param lname:   last name of person to delete
    :return:        200 on successful delete, 404 if not found
    """
    # Does the person to delete exist?
    if lname in PEOPLE:
        del PEOPLE[lname]
        return make_response(
            "{lname} successfully deleted".format(lname=lname), 200
        )

    # Otherwise, nope, person to delete not found
    else:
        abort(
            404, "Person with last name {lname} not found".format(lname=lname)
        )
```

### Poetry

Finally, in order to structure the files needed for the shopping_list repository specify the dependencies, control the python environment and tests  as well as run the code we will be using poetry 0.12.10.

## Test Plan 

## Open Questions
- Do I test using a Test Database ?
- Do I test using mock ?

 